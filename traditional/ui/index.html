<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOS - Traditional Dashboard</title>
    <link rel="stylesheet" href="assets/css/lcars.css">
</head>

<body class="zoom-level-1">
    <div id="tos-root" class="lcars-container">
        <!-- Main Navigation Bar (Left Rail) -->
        <div class="lcars-column">
            <div class="lcars-elbow"></div>
            <div class="lcars-bar"></div>
            <button class="lcars-button" onclick="zoom(2)">Work</button>
            <button class="lcars-button" onclick="zoom(1)">Media</button>
            <button class="lcars-button">System</button>
            <div class="lcars-bar"></div>
        </div>

        <!-- Central Viewport -->
        <div class="viewport-content" id="main-viewport">
            <!-- This area is entirely driven by the Rust backend via generate_viewport_html() -->
            <div id="spatial-view">
                <h1>INITIALIZING TOS...</h1>
            </div>
        </div>
    </div>

    <!-- Floating Context Menu -->
    <div id="context-menu" class="lcars-context-menu">
        <div class="context-menu-item" onclick="handleContextAction('focus')">Focus</div>
        <div class="context-menu-item" onclick="handleContextAction('alert')">Alert Status</div>
        <div class="context-menu-item danger" onclick="handleContextAction('kill')">Terminate</div>
    </div>

    <script>
        // Use a unique ID to maintain focus across innerHTML updates
        let lastCommand = "";
        let contextSurfaceId = null;

        // Function to send commands back to Rust
        function sendCommand(cmd) {
            if (window.ipc) {
                window.ipc.postMessage(cmd);
            } else {
                console.log("Mock Command: " + cmd);
            }
        }

        // Handle Right-click Context Menu
        document.addEventListener('contextmenu', (e) => {
            const frame = e.target.closest('.lcars-window-frame');
            if (frame) {
                e.preventDefault();
                const contentDiv = frame.querySelector('.lcars-window-content');
                if (contentDiv) {
                    contextSurfaceId = contentDiv.id.replace('surface-', '');
                }

                const menu = document.getElementById('context-menu');
                menu.style.display = 'block';
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';
            } else {
                hideContextMenu();
            }
        });

        document.addEventListener('click', () => hideContextMenu());

        function hideContextMenu() {
            const menu = document.getElementById('context-menu');
            menu.style.display = 'none';
        }

        function handleContextAction(action) {
            if (!contextSurfaceId) return;

            switch (action) {
                case 'focus':
                    sendCommand(`zoom:3`); // Simplification for now
                    break;
                case 'kill':
                    sendCommand(`terminal:kill ${contextSurfaceId}`);
                    break;
                case 'alert':
                    sendCommand(`terminal:alert Surface ${contextSurfaceId} status check necessary.`);
                    break;
            }
            hideContextMenu();
        }

        // Handle Terminal Input
        document.addEventListener('keydown', (e) => {
            const input = document.getElementById('terminal-input');
            if (input && document.activeElement === input) {
                if (e.key === 'Enter') {
                    const val = input.value.trim();
                    if (val) {
                        sendCommand("terminal:" + val);
                        input.value = "";
                    }
                }
            }
        });

        // Global Zoom helper for buttons
        function zoom(level) {
            sendCommand("zoom:" + level);
        }

        // Mutation Observer to ensure the input field is always accessible and focused if needed
        const observer = new MutationObserver((mutations) => {
            const input = document.getElementById('terminal-input');
            if (input) {
                // Focus the terminal input whenever it appears if no other element is focused
                if (document.activeElement === document.body || document.activeElement === null) {
                    // input.focus(); // Uncomment if you want auto-focus
                }
            }
        });

        observer.observe(document.body, { childList: true, subtree: true });
    </script>
</body>

</html>