<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOS - Traditional Dashboard</title>
    <link rel="stylesheet" href="assets/css/lcars.css">
</head>

<body class="zoom-level-1">
    <div id="tos-root" class="lcars-container">
        <!-- Main Navigation Bar (Left Rail) -->
        <div class="lcars-column">
            <div class="lcars-elbow"></div>
            <div class="lcars-bar"></div>
            <button class="lcars-button" onclick="zoom(2)">Work</button>
            <button class="lcars-button" onclick="zoom(1)">Media</button>
            <button class="lcars-button">System</button>
            <div class="lcars-bar"></div>
        </div>

        <!-- Central Viewport -->
        <div class="viewport-content" id="main-viewport">
            <!-- This area is entirely driven by the Rust backend via generate_viewport_html() -->
            <div id="spatial-view">
                <h1>INITIALIZING TOS...</h1>
            </div>
        </div>
    </div>

    <!-- Floating Context Menu -->
    <div id="context-menu" class="lcars-context-menu">
        <div id="std-actions">
            <div class="context-menu-item" onclick="handleContextAction('focus')">Focus</div>
            <div class="context-menu-item" onclick="handleContextAction('clone')">New Window</div>
            <div class="context-menu-item" onclick="handleContextAction('inspect')">Inspect Details</div>
            <div class="context-menu-item" onclick="handleContextAction('split')">Compare/Split</div>
        </div>
        <div id="file-actions" style="display: none;">
            <div class="context-menu-item" onclick="handleContextAction('touch')">New File</div>
            <div class="context-menu-item" onclick="handleContextAction('mkdir')">New Folder</div>
        </div>
        <div class="context-menu-item" onclick="handleContextAction('alert')">Alert Status</div>
        <div class="context-menu-item danger" onclick="handleContextAction('kill')">Terminate</div>
    </div>

    <script>
        // Use a unique ID to maintain focus across innerHTML updates
        let lastCommand = "";
        let contextSurfaceId = null;

        // Function to send commands back to Rust
        function sendCommand(cmd) {
            if (window.ipc) {
                window.ipc.postMessage(cmd);
            } else {
                console.log("Mock Command: " + cmd);
            }
        }

        // Handle Right-click Context Menu
        document.addEventListener('contextmenu', (e) => {
            const frame = e.target.closest('.lcars-window-frame');
            if (frame) {
                e.preventDefault();
                const contentDiv = frame.querySelector('.lcars-window-content');
                if (contentDiv) {
                    contextSurfaceId = contentDiv.id.replace('surface-', '');
                }

                const surfaceTitle = frame.querySelector('.title-text')?.innerText || "";

                // Adaptive menu content
                const stdActions = document.getElementById('std-actions');
                const fileActions = document.getElementById('file-actions');

                if (surfaceTitle.toLowerCase().includes("file")) {
                    stdActions.style.display = 'none';
                    fileActions.style.display = 'block';
                } else {
                    stdActions.style.display = 'block';
                    fileActions.style.display = 'none';
                }

                const menu = document.getElementById('context-menu');
                menu.style.display = 'block';
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';
            } else {
                hideContextMenu();
            }
        });

        document.addEventListener('click', () => hideContextMenu());

        function hideContextMenu() {
            const menu = document.getElementById('context-menu');
            menu.style.display = 'none';
        }

        function handleContextAction(action) {
            if (!contextSurfaceId) return;

            switch (action) {
                case 'focus':
                    sendCommand(`zoom:3`); // Simplification for now
                    break;
                case 'clone':
                    sendCommand(`terminal:clone`);
                    break;
                case 'inspect':
                    sendCommand(`terminal:inspect`);
                    break;
                case 'split':
                    sendCommand(`terminal:split ${contextSurfaceId}`);
                    break;
                case 'touch':
                    const fileName = prompt("Enter file name:");
                    if (fileName) sendCommand(`terminal:touch ${fileName}`);
                    break;
                case 'mkdir':
                    const dirName = prompt("Enter directory name:");
                    if (dirName) sendCommand(`terminal:mkdir ${dirName}`);
                    break;
                case 'kill':
                    sendCommand(`terminal:kill ${contextSurfaceId}`);
                    break;
                case 'alert':
                    sendCommand(`terminal:alert Surface ${contextSurfaceId} status check necessary.`);
                    break;
            }
            hideContextMenu();
        }

        // Handle Terminal Input
        document.addEventListener('keydown', (e) => {
            const input = document.getElementById('terminal-input');
            if (input && document.activeElement === input) {
                if (e.key === 'Enter') {
                    const val = input.value.trim();
                    if (val) {
                        sendCommand("terminal:" + val);
                        input.value = "";
                    }
                }
            }
        });

        // Global Zoom helper for buttons
        function zoom(level) {
            sendCommand("zoom:" + level);
        }

        // Tactile Audio Synthesis
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playChirp(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'zoom_in') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'zoom_out') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else {
                // Default notification chirp
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(660, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        }

        function handleAudioBuffer() {
            const buffer = document.getElementById('audio-buffer');
            if (buffer) {
                const sounds = buffer.getAttribute('data-sounds').split(',');
                sounds.forEach(s => playChirp(s));
                buffer.remove(); // Clean up so we don't replay
            }
        }

        // Mutation Observer to handle UI updates and audio
        const observer = new MutationObserver((mutations) => {
            handleAudioBuffer();
            const input = document.getElementById('terminal-input');
            if (input) {
                // ...
            }
        });

        observer.observe(document.body, { childList: true, subtree: true });
    </script>
</body>

</html>