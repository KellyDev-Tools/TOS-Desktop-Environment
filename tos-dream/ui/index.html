<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOS Dream Complete</title>
    <link rel="stylesheet" href="assets/css/lcars.css">
</head>

<body class="level-1">
    <div id="tos-root" class="lcars-grid-base">
        <!-- Persistent Status Bar (Global) -->
        <div class="lcars-status-bar">
            <div class="status-left">TOS VER 1.0 // DREAM COMPLETE</div>
            <div class="status-center" id="current-location">GLOBAL OVERVIEW</div>
            <div class="status-right" id="clock">--:--:--</div>
        </div>

        <!-- Main Content Area -->
        <div id="main-content" class="lcars-main-viewport">
            <h1>INITIALIZING...</h1>
        </div>
    </div>

    <script>
        const hierarchyMap = {
            'GlobalOverview': 0,
            'CommandHub': 1,
            'ApplicationFocus': 2,
            'DetailInspector': 3,
            'BufferInspector': 4,
            'SplitView': 99 // Special case
        };

        let lastLevel = null;
        let isTransitioning = false;
        let lastHtml = null;

        window.handlePromptKey = function (e) {
            if (e.key === 'Enter') {
                window.ipc.postMessage('prompt_submit:' + e.target.value);
                e.target.value = '';
            }
        };

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) window.ipc.postMessage('zoom_in');
            if (e.key === 'Escape') window.ipc.postMessage('zoom_out');
        });

        // The update function called from Rust (indirectly via evaluate_script)
        window.updateView = function (html, currentLevelStr) {
            const container = document.getElementById('main-content');
            if (!container) {
                document.body.innerHTML = "<h1>NO CONTAINER: " + html.substring(0, 100) + "</h1>";
                return;
            }
            const cleanLevel = currentLevelStr.replace(/"/g, ''); // Strip quotes correctly

            // Preserve terminal input state across DOM refresh.
            const oldInput = document.getElementById('terminal-input');
            const inputWasFocused = oldInput && document.activeElement === oldInput;
            const savedValue = oldInput ? oldInput.value : null;
            const savedSelStart = oldInput ? oldInput.selectionStart : 0;
            const savedSelEnd = oldInput ? oldInput.selectionEnd : 0;

            // Optimization: Skip if HTML hasn't changed to prevent flickering
            if (html === lastHtml && cleanLevel === lastLevel) {
                // Still restore input state though, in case focus was lost or value changed externally
                const newInput = document.getElementById('terminal-input');
                if (newInput && savedValue !== null && document.activeElement !== newInput && inputWasFocused) {
                    newInput.focus();
                }
                return;
            }

            // Check if we need to transition
            if (lastLevel && lastLevel !== cleanLevel && !isTransitioning) {
                performTransition(container, html, lastLevel, cleanLevel);
            } else if (!isTransitioning) {
                // Static update
                container.innerHTML = `<div class="viewport-layer active-layer">${html}</div>`;
            }

            // Restore input state after DOM replacement
            const newInput = document.getElementById('terminal-input');
            if (newInput && savedValue !== null) {
                newInput.value = savedValue;
                if (inputWasFocused) {
                    newInput.focus();
                    newInput.selectionStart = savedSelStart;
                    newInput.selectionEnd = savedSelEnd;
                }
            }

            lastLevel = cleanLevel;
            lastHtml = html;
            document.body.className = 'level-' + cleanLevel;
            document.getElementById('current-location').innerText = cleanLevel.toUpperCase();
        };

        function performTransition(container, newHtml, fromLevel, toLevel) {
            isTransitioning = true;

            const fromRank = hierarchyMap[fromLevel] ?? 0;
            const toRank = hierarchyMap[toLevel] ?? 0;
            const direction = toRank > fromRank ? 'in' : 'out';

            // 1. Create layers
            const outgoing = container.querySelector('.viewport-layer') || document.createElement('div');
            outgoing.className = 'viewport-layer zoom-' + direction + '-outgoing';

            const incoming = document.createElement('div');
            incoming.className = 'viewport-layer zoom-' + direction + '-incoming';
            incoming.innerHTML = newHtml;

            // 2. Add to container
            container.appendChild(incoming);

            // 3. Cleanup after animation
            setTimeout(() => {
                if (outgoing.parentNode === container) container.removeChild(outgoing);
                incoming.className = 'viewport-layer active-layer';
                isTransitioning = false;
            }, 600);
        }

        setInterval(() => {
            document.getElementById('clock').innerText = new Date().toLocaleTimeString('en-GB');
        }, 1000);
    </script>
</body>

</html>